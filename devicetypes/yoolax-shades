/**
 *
 *
 *	Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 *	in compliance with the License. You may obtain a copy of the License at:
 *
 *		http://www.apache.org/licenses/LICENSE-2.0
 *
 *	Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
 *	on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
 *	for the specific language governing permissions and limitations under the License.
 *
 */
import physicalgraph.zigbee.zcl.DataType

metadata {
	definition(name: "Yoolax Shades Handler 1", namespace: "thx1200", author: "Timothy Carroll", cstHandler: true) {
		capability "Actuator"
		capability "Configuration"
		capability "Refresh"
		capability "Window Shade"
		capability "Health Check"
		capability "Switch Level"
		capability "Battery"

		command "pause"
		
		attribute "lastCheckin", "String"
		attribute "lastOpened", "String"

		fingerprint inClusters: "0000,0001,0003,0004", manufacturer: "IKEA of Sweden", model: "FYRTUR block-out roller blind"
	}


	tiles(scale: 2) {
		multiAttributeTile(name:"windowShade", type: "generic", width: 6, height: 4) {
			tileAttribute("device.windowShade", key: "PRIMARY_CONTROL") {
				attributeState "opening", label: 'Opening', action: "pause", icon: "st.thermostat.thermostat-up", backgroundColor: "#e86d13", nextState: "partially open"
				attributeState "closing", label: 'Closing', action: "pause", icon: "st.thermostat.thermostat-down", backgroundColor: "#00A0DC", nextState: "partially open"
				attributeState "open", label: 'Open', action: "close", icon: "https://raw.githubusercontent.com/a4refillpad/media/master/blind-open.png", backgroundColor: "#e86d13", nextState: "closing"
				attributeState "closed", label: 'Closed', action: "open", icon: "https://raw.githubusercontent.com/a4refillpad/media/master/blind-closed.png", backgroundColor: "#00A0DC", nextState: "opening"
				attributeState "partially open", label: 'Partially open', action: "close", icon: "https://raw.githubusercontent.com/a4refillpad/media/master/blind-part-open.png", backgroundColor: "#d45614", nextState: "closing"
			}
			tileAttribute("device.lastCheckin", key: "SECONDARY_CONTROL") {
				attributeState("default", label:'Last Update: ${currentValue}',icon: "st.Health & Wellness.health9")
			}
		}
		standardTile("contPause", "device.switch", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
			state "pause", label:"", icon:'st.sonos.stop-btn', action:'pause', backgroundColor:"#cccccc"
		}
		standardTile("refresh", "device.refresh", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
			state "default", label:"", action:"refresh.refresh", icon:"st.secondary.refresh"
		}
		valueTile("shadeLevel", "device.level", width: 3, height: 1) {
			state "level", label: 'Blind is ${currentValue}% open', defaultState: true
		}
		controlTile("levelSliderControl", "device.level", "slider", width:3, height: 1, inactiveLabel: false) {
			state "level", action:"switch level.setLevel"
		}
		standardTile("resetClosed", "device.windowShade", inactiveLabel: false, decoration: "flat", width: 3, height: 1) {
			state "default", action:"close", label: "Close", icon:"https://raw.githubusercontent.com/a4refillpad/media/master/blind-closed.png"
		}
		standardTile("resetOpen", "device.windowShade", inactiveLabel: false, decoration: "flat", width: 3, height: 1) {
			state "default", action:"open", label: "Open", icon:"https://raw.githubusercontent.com/a4refillpad/media/master/blind-open.png"
		}
		valueTile("battery", "device.battery", decoration: "flat", width: 2, height: 2) {
			state "battery", label:'${currentValue}% Battery', unit:"%"
		}

		main "windowShade"
		details(["windowShade", "shadeLevel", "levelSliderControl", "contPause", "battery", "refresh", "resetClosed", "resetOpen"])
	}
}

private getCLUSTER_BATTERY_LEVEL() { 0x0001 }
private getCLUSTER_WINDOW_COVERING() { 0x0102 }
private getCOMMAND_OPEN() { 0x00 }
private getCOMMAND_CLOSE() { 0x01 }
private getCOMMAND_PAUSE() { 0x02 }
private getCOMMAND_GOTO_LIFT_PERCENTAGE() { 0x05 }
private getATTRIBUTE_POSITION_LIFT() { 0x0008 }
private getATTRIBUTE_CURRENT_LEVEL() { 0x0000 }
private getCOMMAND_MOVE_LEVEL_ONOFF() { 0x04 }

def installed() {
	log.info "----------- installed()"
	initialize()
}

def updated() {
	log.info "----------- updated()"
	unsubscribe()
	initialize()
}

def initialize() {
	state.lastDirection = 0
	state.lastLevel = 0
	state.targetLevel = -999
	log.info "----------- initialize()"
}

private List<Map> collectAttributes(Map descMap) {
	List<Map> descMaps = new ArrayList<Map>()

	descMaps.add(descMap)

	if (descMap.additionalAttrs) {
		descMaps.addAll(descMap.additionalAttrs)
	}

	return descMaps
}

// Parse incoming device messages to generate events
def parse(String description) {
	log.debug "description:- ${description}"
	def now = new Date().format("yyyy MMM dd EEE h:mm:ss a", location.timeZone)
	//	send event for heartbeat		
	sendEvent(name: "lastCheckin", value: now)
	if (description?.startsWith("read attr -")) {
		Map descMap = zigbee.parseDescriptionAsMap(description)
		if (descMap?.clusterInt == CLUSTER_WINDOW_COVERING && descMap.value) {
			log.debug "attr: ${descMap?.attrInt}, value: ${descMap?.value}, descValue: ${Integer.parseInt(descMap.value, 16)}, ${device.getDataValue("model")}"
			List<Map> descMaps = collectAttributes(descMap)
			def liftmap = descMaps.find { it.attrInt == ATTRIBUTE_POSITION_LIFT }
			if (liftmap && liftmap.value) {
					def newLevel = 100 - zigbee.convertHexToInt(liftmap.value)
					levelEventHandler(newLevel)
			}
		} 
		if (descMap?.clusterInt == CLUSTER_BATTERY_LEVEL && descMap.value) {
			log.debug "attr: ${descMap?.attrInt}, value: ${descMap?.value}, descValue: ${Integer.parseInt(descMap.value, 16).intdiv(2)}"
			sendEvent(name: "battery", value: Integer.parseInt(descMap.value, 16).intdiv(2), unit: "%", isStateChange: false)
		}
	}
	
	runIn(3, "updateFinalState", [overwrite:true])
}

// Events can and do come in badly out of order with this device, probably because it sends single digit updates over the mesh network.	With some clever "debouncing" we can try to get around this, but even then sometimes the methods fire within current execution.	It seems to work fairly well in practice.
def levelEventHandler(currentLevel) {
	log.debug "levelEventHandle - currentLevel: ${currentLevel} targetlevel: ${state.targetLevel}"

	if (state.lastDirection < -2) { 
		state.lastDirection = -2 
	} else if (state.lastDirection > 2) { 
		state.lastDirection = 2 
	}

	if (currentLevel <= 0) {
		log.debug "levelEventHandle - state: closed"
		sendEvent(name: "windowShade", value: "closed")
	} else if (currentLevel >= 100) {
		log.debug "levelEventHandle - state: open"
		sendEvent(name: "windowShade", value: "open")
	} else if (currentLevel == targetlevel) {
		log.debug "levelEventHandle - state: partially open"
		sendEvent(name: "windowShade", value: "partially open")
	} else if (currentLevel < state.lastLevel) {
		if (state.lastDirection <= 0) {
			log.debug "levelEventHandle - state: closing (${state.lastDirection})"
			sendEvent(name:"windowShade", value: "closing")
		} else {
			log.debug "levelEventHandle - state: closing -debounce- (${state.lastDirection})"
		}
		state.lastDirection = state.lastDirection - 1
	} else if (currentLevel > state.lastLevel) {
		if (state.lastDirection >= 0) {
			log.debug "levelEventHandle - state: opening (${state.lastDirection})"
			sendEvent(name:"windowShade", value: "opening")
		} else {
			log.debug "levelEventHandle - state: opening -debounce- (${state.lastDirection})"
		}
		state.lastDirection = state.lastDirection + 1
	}

	log.debug "lastDirection ${state.lastDirection}"

	state.lastLevel = currentLevel
}

def updateFinalState() {
	log.debug "updateFinalState: targetlevel: ${state.targetLevel}, lastlevel: ${state.lastLevel}"

	def targetlevel = nearestFive(state.lastLevel)
	if (state.targetLevel >= 0 && state.targetLevel <= 100 && Math.abs(state.targetLevel - state.lastLevel) < 5) {
		log.debug "updateFinalState: using targetlevel value"
		targetlevel = state.targetLevel
	} else {
		log.debug "updateFinalState: using lastLevel value"
	}
		
	sendEvent(name: "level", value: targetlevel)
	log.debug "updateFinalState: level: ${targetlevel}"
	
	if (targetlevel <= 0) {
		log.debug "updateFinalState - state: closed"
		sendEvent(name: "windowShade", value: "closed")
	} else if (targetlevel >= 100) {
		log.debug "updateFinalState - state: open"
		sendEvent(name: "windowShade", value: "open")
	} else {
		log.debug "updateFinalState - state: partially open"
			sendEvent(name: "windowShade", value: "partially open")
	}
	
	state.lastDirection = 0
	state.targetLevel = -999
}

def close() {
	log.info "close()"
	setLevel(0)
}

def open() {
	log.info "open()"
	setLevel(100)
}

def setLevel(data, rate = null) {
	data = nearestFive(data).toInteger()
	log.info "setLevel ${data}"

	state.lastDirection = 0
	state.targetLevel = data
	sendEvent(name: "level", value: data)

	def cmd
	cmd = zigbee.command(CLUSTER_WINDOW_COVERING, COMMAND_GOTO_LIFT_PERCENTAGE, zigbee.convertToHexString(100 - data, 2))

	return cmd
}

def pause() {
	log.info "pause()"
	setLevel(state.lastLevel)
}

def nearestFive(val) {
	return 5 * (Math.round(val/5))
}

/**
 * PING is used by Device-Watch in attempt to reach the Device
 * */

def ping() {
	log.info "ping()"
		
	def cmds = zigbee.readAttribute(CLUSTER_WINDOW_COVERING, ATTRIBUTE_POSITION_LIFT) + zigbee.readAttribute(CLUSTER_WINDOW_COVERING, ATTRIBUTE_CURRENT_LEVEL) + zigbee.readAttribute(CLUSTER_BATTERY_LEVEL, 0x0021) 
	return cmds
}

def refresh() {
	log.info "refresh()"
	
	def cmds
	cmds = zigbee.readAttribute(CLUSTER_WINDOW_COVERING, ATTRIBUTE_POSITION_LIFT) + zigbee.readAttribute(CLUSTER_WINDOW_COVERING, ATTRIBUTE_CURRENT_LEVEL) + zigbee.readAttribute(CLUSTER_BATTERY_LEVEL, 0x0021) 

	runIn(3, "updateFinalState", [overwrite:true])

	return cmds
}

def configure() {
	// Device-Watch allows 2 check-in misses from device + ping (plus 2 min lag time)
	log.info "configure()"
	sendEvent(name: "checkInterval", value: 2 * 60 * 60 + 2 * 60, displayed: false, data: [protocol: "zigbee", hubHardwareId: device.hub.hardwareID])
	log.debug "Configuring Reporting and Bindings."

	def cmds
	cmds = zigbee.configureReporting(CLUSTER_WINDOW_COVERING, ATTRIBUTE_POSITION_LIFT, DataType.UINT8, 0, 600, null) + zigbee.configureReporting(CLUSTER_BATTERY_LEVEL, 0x0021, DataType.UINT8, 600, 21600, 0x01)

	return refresh() + cmds
}
